<!DOCTYPE html>
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=utf8"/>
<title>图片材质</title>
</head>

 <script type="text/javascript" src="../../js/jquery-1.7.1.js"></script>
<script type="text/javascript" src="../../js/three.js"></script>
<script type="text/javascript" src="../../js/SceneUtils.js"></script>
<script type="text/javascript" src="../../js/Stats.js"></script>
<script type="text/javascript" src="../../js/TrackballControls.js"></script>
<script type="text/javascript" src="../../js/dat.gui.js"></script>

<script type="text/javascript">
$(function(){
	var  version=THREE.REVISION;	
	$("#version").html(version);
})
</script>
<body>
<span id="version"></span>
<div id="div1"></div>
</body>
<script type="text/javascript">
//三大组件

var scene;//场景
var camera;//相机
var renderer;//渲染器
var axes;//坐标
//球形轨道控制器
var controls;
var stats;
var wuti_boj;//自定义物体
var cube_obj;
var wuti_list=[];
$(function(){
	 inits();//初始化组件
	 add_spotlight()//光源
     add_plane();//平面
     //自定义物体：
	 zidingyi();
	 zidingyi1();
	 shc_start();//开始渲染
})
//初始化组件：
function inits(){
	 //场景（所有图形存在的空间）
	 scene = new THREE.Scene();
	   // 透视相机
     camera = new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,1000);
     camera.position.set(-30,30,30);
     camera.lookAt(0,4,0);
	   // 渲染器
     renderer = new THREE.WebGLRenderer();
    // 设置渲染器的大小为窗口的内宽度，也就是内容区的宽度
    renderer.setClearColor(0xeeeeee);
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMapEnabled;
    renderer.shadowMapEnabled = true;
    //渲染器加入html
    $("#div1").append(renderer.domElement); 
    //加入fps
	stats = new Stats();
    document.body.appendChild(stats.dom);
}      
function shc_start(){
	 //渲染
    //renderer.render(scene, camera);
   animate1();
}     
//动态函数
function animate(){
    //controls.update();
    stats.update();
    var sudu=0.003;
    cube_obj.rotation.y +=0.003; 
    cube_obj.rotation.x +=0.003; 
    cube_obj.rotation.z +=0.003;
    for(var n in wuti_list){
    	var wutis=wuti_list[n];
    	wutis.rotation.y +=sudu; 
    	wutis.rotation.x +=sudu; 
    	wutis.rotation.z +=sudu;
    }
    requestAnimationFrame(animate);
    renderer.render(scene,camera);
}
function animate1(){
	//cube_obj.rotation.y +=0.003; 
    cube_obj.rotation.x +=1; 
   // cube_obj.rotation.z +=0.003;
	 var cube_gemo=cube_obj.geometry;
	 var face_list=cube_gemo.faces;//获取物体框架的面（face：每个face由三个点组成）
	 var normal=face_list[0].normal;//获取一个面的法向量
	 var vector3=cube_gemo.vertices;//获取物体框架的所有点（vertices）
	 requestAnimationFrame(animate1);
     renderer.render(scene,camera);
}


function onResize(){
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
//添加控制器
function controls_init(){
    //球形轨道控制器
    controls = new THREE.TrackballControls(camera,renderer.domElement);
    controls.maxDistance = 400.0;
    controls.minDistance = 10.0;
    controls.target = new THREE.Vector3(0,3,0);
}

//添加光源
function add_spotlight(){
	//1.环境光
	  light = new THREE.AmbientLight(0x990000);//a.光的颜色
   light.position.set(100, 100, 200); 
	/*  //2.平行光
	// 第二个参数是光源强度，你可以改变它试一下
	light = new THREE.DirectionalLight(0xFF0000,1);
	// 位置不同，方向光作用于物体的面也不同，看到的物体各个面的颜色也不一样
	light.position.set(0,0,1); 
	scene.add(light);
	
	//再添加一个光源
	light1 = new THREE.DirectionalLight(0x00FF00,1);
	light1.position.set(1,0,0); 
	scene.add(light1);
	*/
	//环境光
	light3 = new THREE.AmbientLight("#494");//a.光的颜色
	light3.position.set(100, 100, 200);
	scene.add(light3); 
	
	//点光源
	light4 = new THREE.PointLight(0xFF0000);
	light4.position.set(0,0,50);
	scene.add(light4);
}
//添加一平面	
function add_plane(){
	var plane=new THREE.PlaneGeometry(200,80);
	var plane_mesh=new THREE.MeshLambertMaterial({color:0xffffff});
	var plane_obj=new THREE.Mesh(plane,plane_mesh);
	plane_obj.rotation.x=-0.5*Math.PI;
	plane_obj.position.x=15;
	plane_obj.position.y=0;
	plane_obj.position.z=0;
	plane_obj.receiveShadow=true;//接受阴影
	scene.add(plane_obj);
	return plane_obj;
}		
function zidingyi(){
	//定义一组点
	var vertices=[
		new THREE.Vector3(0,0,0),
		new THREE.Vector3(0,0,10),
		new THREE.Vector3(0,10,0),
		new THREE.Vector3(10,0,0),
		new THREE.Vector3(10,10,0),
		new THREE.Vector3(0,10,10),
		new THREE.Vector3(10,0,10),
		new THREE.Vector3(10,10,10)
	];
	//定义一组面（从点数组中取点生产面：三点生产一面）
	var faces1=[
		new THREE.Face3(5,1,7)//每两个三角形组成一个平面(传入点数组下标，从0开始)
		 ,new THREE.Face3(1,6,7)
	];
	var faces2=[
		new THREE.Face3(3,4,6)//
		, new THREE.Face3(4,7,6)
	];
	var faces3=[
		new THREE.Face3(2,4,0)//
		, new THREE.Face3(4,3,0)
	];
	var faces4=[
		new THREE.Face3(2,0,5)//
		, new THREE.Face3(0,1,5)
	];
	var faces5=[
		new THREE.Face3(5,7,2)//
		, new THREE.Face3(7,4,2)
	];
	var faces6=[
		new THREE.Face3(1,0,6)//
		, new THREE.Face3(0,3,6) 
	];
	var faces_list=[faces1,faces2,faces3,faces4,faces5,faces6];
	for(var i=0;i<6;i++){
		var mapUrl="http://localhost:8080/webgl/image/sezi/"+(i+1)+".png";
		//mapUrl="http://localhost:8080/webgl/image/aa.jpg";
		var map=THREE.ImageUtils.loadTexture(mapUrl);
		 //2.创建一个基础材质，传入纹理映射
		var material=new THREE.MeshBasicMaterial({map:map});
		var geom=new THREE.PlaneGeometry();//创建一个物体对象
		geom.vertices=vertices;
		geom.faces=faces_list[i];
		/* geom.computeFaceNormals();
		geom.computeVertexNormals();
		geom.mergeVertices(); */
	    var wuti_boj = new THREE.Mesh(geom,material);
	    wuti_boj.translateY(10);
		scene.add(wuti_boj);
		wuti_list.push(wuti_boj);
	}
} 
function zidingyi1(){
    var cube_list=[];
	var cube=new THREE.CubeGeometry(4,4,4);
	for(var i=0;i<6;i++){
		var mapUrl="http://localhost:8080/webgl/image/sezi/"+(i+1)+".png";
		//mapUrl="http://localhost:8080/webgl/image/aa.jpg";
		var map=THREE.ImageUtils.loadTexture(mapUrl);
	      //2.创建一个基础材质，传入纹理映射
	      var material=new THREE.MeshBasicMaterial({map:map});
		cube_list.push(material);
	}
	var faceMaterial=new THREE.MeshFaceMaterial(cube_list);
	cube_obj =new THREE.Mesh(cube,faceMaterial);
	cube_obj.position.set(-20,10,0) 
	scene.add(cube_obj);
}
</script>
</html>